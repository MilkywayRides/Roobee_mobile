# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE name = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                },
                {
                    # data to create a User record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'ggciceaie',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'bbehjachib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'cadfabfehe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the email field
        users = await User.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the emailVerified field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'emailVerified': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the image field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'image': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'dgiiaaijj',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'bfaiacjjfc',
            },
            data={
                'create': {
                    'id': 'bfaiacjjfc',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'password': 'eigcfgbif'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'role': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'resetToken': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by resetTokenExpiry values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['resetTokenExpiry'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AccountActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Account]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Account.prisma().query_raw(
            'SELECT * FROM Account WHERE id = $1',
            'bagcfbhiig',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Account
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Account.prisma().query_first(
            'SELECT * FROM Account WHERE userId = $1',
            'cghideieh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AccountCreateInput,
        include: Optional[types.AccountInclude] = None
    ) -> _PrismaModelT:
        """Create a new Account record.

        Parameters
        ----------
        data
            Account record data
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The created Account record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Account record from just the required fields
        account = await Account.prisma().create(
            data={
                # data to create a Account record
                'userId': 'biabhbdai',
                'type': 'idghgaicb',
                'provider': 'fjfddhigg',
                'providerAccountId': 'hjaecfifb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AccountCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Account records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Account record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Account.prisma().create_many(
            data=[
                {
                    # data to create a Account record
                    'userId': 'cbbbjbfcii',
                    'type': 'bbejhfidcb',
                    'provider': 'bgeecijdgg',
                    'providerAccountId': 'bdiicjafbj',
                },
                {
                    # data to create a Account record
                    'userId': 'bgehebiafc',
                    'type': 'bghffegacj',
                    'provider': 'bhghchehcc',
                    'providerAccountId': 'dcgchcbbf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Account record.

        Parameters
        ----------
        where
            Account filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The deleted Account record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().delete(
            where={
                'id': 'bdedcabahc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Account record.

        Parameters
        ----------
        where
            Account filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The found Account record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().find_unique(
            where={
                'id': 'ghfhiafcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Account record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Account filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The found Account record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().find_unique_or_raise(
            where={
                'id': 'heejgedji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
        include: Optional[types.AccountInclude] = None,
        order: Optional[Union[types.AccountOrderByInput, List[types.AccountOrderByInput]]] = None,
        distinct: Optional[List[types.AccountScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Account records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Account records returned
        skip
            Ignore the first N results
        where
            Account filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Account model
        order
            Order the returned Account records by any field
        distinct
            Filter Account records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Account]
            The list of all Account records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Account records
        accounts = await Account.prisma().find_many(take=10)

        # find the first 5 Account records ordered by the type field
        accounts = await Account.prisma().find_many(
            take=5,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
        include: Optional[types.AccountInclude] = None,
        order: Optional[Union[types.AccountOrderByInput, List[types.AccountOrderByInput]]] = None,
        distinct: Optional[List[types.AccountScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Account record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Account filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Account model
        order
            Order the returned Account records by any field
        distinct
            Filter Account records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Account
            The first Account record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Account record ordered by the provider field
        account = await Account.prisma().find_first(
            skip=1,
            order={
                'provider': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
        include: Optional[types.AccountInclude] = None,
        order: Optional[Union[types.AccountOrderByInput, List[types.AccountOrderByInput]]] = None,
        distinct: Optional[List[types.AccountScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Account record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Account filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Account model
        order
            Order the returned Account records by any field
        distinct
            Filter Account records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Account
            The first Account record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Account record ordered by the providerAccountId field
        account = await Account.prisma().find_first_or_raise(
            skip=1,
            order={
                'providerAccountId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AccountUpdateInput,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Account record.

        Parameters
        ----------
        data
            Account record data specifying what to update
        where
            Account filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The updated Account record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        account = await Account.prisma().update(
            where={
                'id': 'bjgjgibgbf',
            },
            data={
                # data to update the Account record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AccountWhereUniqueInput,
        data: types.AccountUpsertInput,
        include: Optional[types.AccountInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Account filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The created or updated Account record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().upsert(
            where={
                'id': 'bbbgbhfjge',
            },
            data={
                'create': {
                    'id': 'bbbgbhfjge',
                    'userId': 'bgehebiafc',
                    'type': 'bghffegacj',
                    'provider': 'bhghchehcc',
                    'providerAccountId': 'dcgchcbbf',
                },
                'update': {
                    'userId': 'bgehebiafc',
                    'type': 'bghffegacj',
                    'provider': 'bhghchehcc',
                    'providerAccountId': 'dcgchcbbf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AccountUpdateManyMutationInput,
        where: types.AccountWhereInput,
    ) -> int:
        """Update multiple Account records

        Parameters
        ----------
        data
            Account data to update the selected Account records to
        where
            Filter to select the Account records to update

        Returns
        -------
        int
            The total number of Account records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Account records
        total = await Account.prisma().update_many(
            data={
                'refresh_token': 'igbehcbab'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Account records present in the database

        Parameters
        ----------
        select
            Select the Account fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Account filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AccountCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Account.prisma().count()

        # results: prisma.types.AccountCountAggregateOutput
        results = await Account.prisma().count(
            select={
                '_all': True,
                'access_token': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AccountCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
    ) -> types.AccountCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AccountCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
    ) -> Union[int, types.AccountCountAggregateOutput]:
        """Count the number of Account records present in the database

        Parameters
        ----------
        select
            Select the Account fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Account filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AccountCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Account.prisma().count()

        # results: prisma.types.AccountCountAggregateOutput
        results = await Account.prisma().count(
            select={
                '_all': True,
                'expires_at': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AccountCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AccountWhereInput] = None
    ) -> int:
        """Delete multiple Account records.

        Parameters
        ----------
        where
            Optional Account filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Account records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Account records
        total = await Account.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AccountScalarFieldKeys'],
        *,
        where: Optional['types.AccountWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AccountAvgAggregateInput'] = None,
        sum: Optional['types.AccountSumAggregateInput'] = None,
        min: Optional['types.AccountMinAggregateInput'] = None,
        max: Optional['types.AccountMaxAggregateInput'] = None,
        having: Optional['types.AccountScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AccountCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AccountScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AccountScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AccountGroupByOutput']:
        """Group Account records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Account fields to group records by
        where
            Account filter to select records
        take
            Limit the maximum number of Account records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AccountGroupByOutput]
            A list of dictionaries representing the Account record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Account records by token_type values
        # and count how many records are in each group
        results = await Account.prisma().group_by(
            ['token_type'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SessionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Session]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Session.prisma().query_raw(
            'SELECT * FROM Session WHERE id = $1',
            'bdadaadhag',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Session
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Session.prisma().query_first(
            'SELECT * FROM Session WHERE sessionToken = $1',
            'bgiggdidbf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SessionCreateInput,
        include: Optional[types.SessionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Session record.

        Parameters
        ----------
        data
            Session record data
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The created Session record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Session record from just the required fields
        session = await Session.prisma().create(
            data={
                # data to create a Session record
                'sessionToken': 'caaaedabfc',
                'userId': 'bigibebcib',
                'expires': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SessionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Session records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Session record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Session.prisma().create_many(
            data=[
                {
                    # data to create a Session record
                    'sessionToken': 'bigaiehgcc',
                    'userId': 'beeifcbebf',
                    'expires': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Session record
                    'sessionToken': 'bgcigfahea',
                    'userId': 'bcejgaggif',
                    'expires': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Session record.

        Parameters
        ----------
        where
            Session filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The deleted Session record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().delete(
            where={
                'id': 'idfjadbcc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Session record.

        Parameters
        ----------
        where
            Session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The found Session record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().find_unique(
            where={
                'id': 'hgdhbjhhj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Session record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The found Session record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().find_unique_or_raise(
            where={
                'id': 'ecjjjfbae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Session records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Session records returned
        skip
            Ignore the first N results
        where
            Session filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Session]
            The list of all Session records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Session records
        sessions = await Session.prisma().find_many(take=10)

        # find the first 5 Session records ordered by the userId field
        sessions = await Session.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Session record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Session
            The first Session record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Session record ordered by the expires field
        session = await Session.prisma().find_first(
            skip=1,
            order={
                'expires': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Session record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Session
            The first Session record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Session record ordered by the id field
        session = await Session.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SessionUpdateInput,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Session record.

        Parameters
        ----------
        data
            Session record data specifying what to update
        where
            Session filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The updated Session record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        session = await Session.prisma().update(
            where={
                'id': 'bhhfibbigf',
            },
            data={
                # data to update the Session record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SessionWhereUniqueInput,
        data: types.SessionUpsertInput,
        include: Optional[types.SessionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Session filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The created or updated Session record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().upsert(
            where={
                'id': 'ijdbeffgg',
            },
            data={
                'create': {
                    'id': 'ijdbeffgg',
                    'sessionToken': 'bgcigfahea',
                    'userId': 'bcejgaggif',
                    'expires': datetime.datetime.utcnow(),
                },
                'update': {
                    'sessionToken': 'bgcigfahea',
                    'userId': 'bcejgaggif',
                    'expires': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SessionUpdateManyMutationInput,
        where: types.SessionWhereInput,
    ) -> int:
        """Update multiple Session records

        Parameters
        ----------
        data
            Session data to update the selected Session records to
        where
            Filter to select the Session records to update

        Returns
        -------
        int
            The total number of Session records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Session records
        total = await Session.prisma().update_many(
            data={
                'sessionToken': 'jjfeafhfj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Session records present in the database

        Parameters
        ----------
        select
            Select the Session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Session.prisma().count()

        # results: prisma.types.SessionCountAggregateOutput
        results = await Session.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SessionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> types.SessionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SessionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> Union[int, types.SessionCountAggregateOutput]:
        """Count the number of Session records present in the database

        Parameters
        ----------
        select
            Select the Session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Session.prisma().count()

        # results: prisma.types.SessionCountAggregateOutput
        results = await Session.prisma().count(
            select={
                '_all': True,
                'expires': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SessionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SessionWhereInput] = None
    ) -> int:
        """Delete multiple Session records.

        Parameters
        ----------
        where
            Optional Session filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Session records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Session records
        total = await Session.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SessionScalarFieldKeys'],
        *,
        where: Optional['types.SessionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SessionAvgAggregateInput'] = None,
        sum: Optional['types.SessionSumAggregateInput'] = None,
        min: Optional['types.SessionMinAggregateInput'] = None,
        max: Optional['types.SessionMaxAggregateInput'] = None,
        having: Optional['types.SessionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SessionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SessionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SessionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SessionGroupByOutput']:
        """Group Session records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Session fields to group records by
        where
            Session filter to select records
        take
            Limit the maximum number of Session records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SessionGroupByOutput]
            A list of dictionaries representing the Session record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Session records by id values
        # and count how many records are in each group
        results = await Session.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class VerificationTokenActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.VerificationToken]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await VerificationToken.prisma().query_raw(
            'SELECT * FROM VerificationToken WHERE identifier = $1',
            'cbachdgfce',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.VerificationToken
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await VerificationToken.prisma().query_first(
            'SELECT * FROM VerificationToken WHERE token = $1',
            'chbfcacbd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.VerificationTokenCreateInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> _PrismaModelT:
        """Create a new VerificationToken record.

        Parameters
        ----------
        data
            VerificationToken record data
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The created VerificationToken record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a VerificationToken record from just the required fields
        verificationtoken = await VerificationToken.prisma().create(
            data={
                # data to create a VerificationToken record
                'identifier': 'efggddide',
                'token': 'caficfigfb',
                'expires': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.VerificationTokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple VerificationToken records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of VerificationToken record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await VerificationToken.prisma().create_many(
            data=[
                {
                    # data to create a VerificationToken record
                    'identifier': 'bfidgijfjc',
                    'token': 'ihieecagf',
                    'expires': datetime.datetime.utcnow(),
                },
                {
                    # data to create a VerificationToken record
                    'identifier': 'bghfciaafe',
                    'token': 'bgchfhgceh',
                    'expires': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.VerificationTokenWhereUniqueInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single VerificationToken record.

        Parameters
        ----------
        where
            VerificationToken filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The deleted VerificationToken record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        verificationtoken = await VerificationToken.prisma().delete(
            where={
                'token': 'cafeiaccbc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.VerificationTokenWhereUniqueInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique VerificationToken record.

        Parameters
        ----------
        where
            VerificationToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The found VerificationToken record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        verificationtoken = await VerificationToken.prisma().find_unique(
            where={
                'token': 'gaddfhfh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.VerificationTokenWhereUniqueInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> _PrismaModelT:
        """Find a unique VerificationToken record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            VerificationToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The found VerificationToken record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        verificationtoken = await VerificationToken.prisma().find_unique_or_raise(
            where={
                'token': 'gieegcbeg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
        include: Optional[types.VerificationTokenInclude] = None,
        order: Optional[Union[types.VerificationTokenOrderByInput, List[types.VerificationTokenOrderByInput]]] = None,
        distinct: Optional[List[types.VerificationTokenScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple VerificationToken records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of VerificationToken records returned
        skip
            Ignore the first N results
        where
            VerificationToken filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned VerificationToken model
        order
            Order the returned VerificationToken records by any field
        distinct
            Filter VerificationToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.VerificationToken]
            The list of all VerificationToken records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 VerificationToken records
        verificationtokens = await VerificationToken.prisma().find_many(take=10)

        # find the first 5 VerificationToken records ordered by the expires field
        verificationtokens = await VerificationToken.prisma().find_many(
            take=5,
            order={
                'expires': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
        include: Optional[types.VerificationTokenInclude] = None,
        order: Optional[Union[types.VerificationTokenOrderByInput, List[types.VerificationTokenOrderByInput]]] = None,
        distinct: Optional[List[types.VerificationTokenScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single VerificationToken record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            VerificationToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned VerificationToken model
        order
            Order the returned VerificationToken records by any field
        distinct
            Filter VerificationToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.VerificationToken
            The first VerificationToken record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second VerificationToken record ordered by the identifier field
        verificationtoken = await VerificationToken.prisma().find_first(
            skip=1,
            order={
                'identifier': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
        include: Optional[types.VerificationTokenInclude] = None,
        order: Optional[Union[types.VerificationTokenOrderByInput, List[types.VerificationTokenOrderByInput]]] = None,
        distinct: Optional[List[types.VerificationTokenScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single VerificationToken record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            VerificationToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned VerificationToken model
        order
            Order the returned VerificationToken records by any field
        distinct
            Filter VerificationToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.VerificationToken
            The first VerificationToken record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second VerificationToken record ordered by the token field
        verificationtoken = await VerificationToken.prisma().find_first_or_raise(
            skip=1,
            order={
                'token': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.VerificationTokenUpdateInput,
        where: types.VerificationTokenWhereUniqueInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single VerificationToken record.

        Parameters
        ----------
        data
            VerificationToken record data specifying what to update
        where
            VerificationToken filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The updated VerificationToken record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        verificationtoken = await VerificationToken.prisma().update(
            where={
                'token': 'bgcffadich',
            },
            data={
                # data to update the VerificationToken record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.VerificationTokenWhereUniqueInput,
        data: types.VerificationTokenUpsertInput,
        include: Optional[types.VerificationTokenInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            VerificationToken filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The created or updated VerificationToken record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        verificationtoken = await VerificationToken.prisma().upsert(
            where={
                'token': 'fcbichhci',
            },
            data={
                'create': {
                    'token': 'fcbichhci',
                    'identifier': 'bghfciaafe',
                    'expires': datetime.datetime.utcnow(),
                },
                'update': {
                    'identifier': 'bghfciaafe',
                    'expires': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.VerificationTokenUpdateManyMutationInput,
        where: types.VerificationTokenWhereInput,
    ) -> int:
        """Update multiple VerificationToken records

        Parameters
        ----------
        data
            VerificationToken data to update the selected VerificationToken records to
        where
            Filter to select the VerificationToken records to update

        Returns
        -------
        int
            The total number of VerificationToken records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all VerificationToken records
        total = await VerificationToken.prisma().update_many(
            data={
                'expires': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
    ) -> int:
        """Count the number of VerificationToken records present in the database

        Parameters
        ----------
        select
            Select the VerificationToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            VerificationToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VerificationTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await VerificationToken.prisma().count()

        # results: prisma.types.VerificationTokenCountAggregateOutput
        results = await VerificationToken.prisma().count(
            select={
                '_all': True,
                'identifier': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.VerificationTokenCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
    ) -> types.VerificationTokenCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.VerificationTokenCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
    ) -> Union[int, types.VerificationTokenCountAggregateOutput]:
        """Count the number of VerificationToken records present in the database

        Parameters
        ----------
        select
            Select the VerificationToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            VerificationToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VerificationTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await VerificationToken.prisma().count()

        # results: prisma.types.VerificationTokenCountAggregateOutput
        results = await VerificationToken.prisma().count(
            select={
                '_all': True,
                'token': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.VerificationTokenCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.VerificationTokenWhereInput] = None
    ) -> int:
        """Delete multiple VerificationToken records.

        Parameters
        ----------
        where
            Optional VerificationToken filter to find the records to be deleted

        Returns
        -------
        int
            The total number of VerificationToken records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all VerificationToken records
        total = await VerificationToken.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.VerificationTokenScalarFieldKeys'],
        *,
        where: Optional['types.VerificationTokenWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.VerificationTokenAvgAggregateInput'] = None,
        sum: Optional['types.VerificationTokenSumAggregateInput'] = None,
        min: Optional['types.VerificationTokenMinAggregateInput'] = None,
        max: Optional['types.VerificationTokenMaxAggregateInput'] = None,
        having: Optional['types.VerificationTokenScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.VerificationTokenCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.VerificationTokenScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.VerificationTokenScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.VerificationTokenGroupByOutput']:
        """Group VerificationToken records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar VerificationToken fields to group records by
        where
            VerificationToken filter to select records
        take
            Limit the maximum number of VerificationToken records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.VerificationTokenGroupByOutput]
            A list of dictionaries representing the VerificationToken record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group VerificationToken records by expires values
        # and count how many records are in each group
        results = await VerificationToken.prisma().group_by(
            ['expires'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PasswordResetTokenActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PasswordResetToken]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PasswordResetToken.prisma().query_raw(
            'SELECT * FROM PasswordResetToken WHERE id = $1',
            'bcggadccgf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PasswordResetToken
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PasswordResetToken.prisma().query_first(
            'SELECT * FROM PasswordResetToken WHERE token = $1',
            'jdcfdcgc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PasswordResetTokenCreateInput,
        include: Optional[types.PasswordResetTokenInclude] = None
    ) -> _PrismaModelT:
        """Create a new PasswordResetToken record.

        Parameters
        ----------
        data
            PasswordResetToken record data
        include
            Specifies which relations should be loaded on the returned PasswordResetToken model

        Returns
        -------
        prisma.models.PasswordResetToken
            The created PasswordResetToken record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PasswordResetToken record from just the required fields
        passwordresettoken = await PasswordResetToken.prisma().create(
            data={
                # data to create a PasswordResetToken record
                'token': 'cafdaehjid',
                'userId': 'gifdddbia',
                'expires': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PasswordResetTokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PasswordResetToken records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PasswordResetToken record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PasswordResetToken.prisma().create_many(
            data=[
                {
                    # data to create a PasswordResetToken record
                    'token': 'bchehecef',
                    'userId': 'jeijcbhfe',
                    'expires': datetime.datetime.utcnow(),
                },
                {
                    # data to create a PasswordResetToken record
                    'token': 'bjgejjabff',
                    'userId': 'bcciijbibg',
                    'expires': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PasswordResetTokenWhereUniqueInput,
        include: Optional[types.PasswordResetTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PasswordResetToken record.

        Parameters
        ----------
        where
            PasswordResetToken filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PasswordResetToken model

        Returns
        -------
        prisma.models.PasswordResetToken
            The deleted PasswordResetToken record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        passwordresettoken = await PasswordResetToken.prisma().delete(
            where={
                'id': 'cffcachfd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PasswordResetTokenWhereUniqueInput,
        include: Optional[types.PasswordResetTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PasswordResetToken record.

        Parameters
        ----------
        where
            PasswordResetToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PasswordResetToken model

        Returns
        -------
        prisma.models.PasswordResetToken
            The found PasswordResetToken record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        passwordresettoken = await PasswordResetToken.prisma().find_unique(
            where={
                'id': 'bccdfhdigc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PasswordResetTokenWhereUniqueInput,
        include: Optional[types.PasswordResetTokenInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PasswordResetToken record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PasswordResetToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PasswordResetToken model

        Returns
        -------
        prisma.models.PasswordResetToken
            The found PasswordResetToken record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        passwordresettoken = await PasswordResetToken.prisma().find_unique_or_raise(
            where={
                'id': 'febcgjbfj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PasswordResetTokenWhereInput] = None,
        cursor: Optional[types.PasswordResetTokenWhereUniqueInput] = None,
        include: Optional[types.PasswordResetTokenInclude] = None,
        order: Optional[Union[types.PasswordResetTokenOrderByInput, List[types.PasswordResetTokenOrderByInput]]] = None,
        distinct: Optional[List[types.PasswordResetTokenScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PasswordResetToken records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PasswordResetToken records returned
        skip
            Ignore the first N results
        where
            PasswordResetToken filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PasswordResetToken model
        order
            Order the returned PasswordResetToken records by any field
        distinct
            Filter PasswordResetToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PasswordResetToken]
            The list of all PasswordResetToken records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PasswordResetToken records
        passwordresettokens = await PasswordResetToken.prisma().find_many(take=10)

        # find the first 5 PasswordResetToken records ordered by the userId field
        passwordresettokens = await PasswordResetToken.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PasswordResetTokenWhereInput] = None,
        cursor: Optional[types.PasswordResetTokenWhereUniqueInput] = None,
        include: Optional[types.PasswordResetTokenInclude] = None,
        order: Optional[Union[types.PasswordResetTokenOrderByInput, List[types.PasswordResetTokenOrderByInput]]] = None,
        distinct: Optional[List[types.PasswordResetTokenScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PasswordResetToken record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PasswordResetToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PasswordResetToken model
        order
            Order the returned PasswordResetToken records by any field
        distinct
            Filter PasswordResetToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PasswordResetToken
            The first PasswordResetToken record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PasswordResetToken record ordered by the expires field
        passwordresettoken = await PasswordResetToken.prisma().find_first(
            skip=1,
            order={
                'expires': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PasswordResetTokenWhereInput] = None,
        cursor: Optional[types.PasswordResetTokenWhereUniqueInput] = None,
        include: Optional[types.PasswordResetTokenInclude] = None,
        order: Optional[Union[types.PasswordResetTokenOrderByInput, List[types.PasswordResetTokenOrderByInput]]] = None,
        distinct: Optional[List[types.PasswordResetTokenScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PasswordResetToken record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PasswordResetToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PasswordResetToken model
        order
            Order the returned PasswordResetToken records by any field
        distinct
            Filter PasswordResetToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PasswordResetToken
            The first PasswordResetToken record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PasswordResetToken record ordered by the createdAt field
        passwordresettoken = await PasswordResetToken.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PasswordResetTokenUpdateInput,
        where: types.PasswordResetTokenWhereUniqueInput,
        include: Optional[types.PasswordResetTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PasswordResetToken record.

        Parameters
        ----------
        data
            PasswordResetToken record data specifying what to update
        where
            PasswordResetToken filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PasswordResetToken model

        Returns
        -------
        prisma.models.PasswordResetToken
            The updated PasswordResetToken record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        passwordresettoken = await PasswordResetToken.prisma().update(
            where={
                'id': 'bageiegghg',
            },
            data={
                # data to update the PasswordResetToken record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PasswordResetTokenWhereUniqueInput,
        data: types.PasswordResetTokenUpsertInput,
        include: Optional[types.PasswordResetTokenInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PasswordResetToken filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PasswordResetToken model

        Returns
        -------
        prisma.models.PasswordResetToken
            The created or updated PasswordResetToken record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        passwordresettoken = await PasswordResetToken.prisma().upsert(
            where={
                'id': 'faidicegb',
            },
            data={
                'create': {
                    'id': 'faidicegb',
                    'token': 'bjgejjabff',
                    'userId': 'bcciijbibg',
                    'expires': datetime.datetime.utcnow(),
                },
                'update': {
                    'token': 'bjgejjabff',
                    'userId': 'bcciijbibg',
                    'expires': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PasswordResetTokenUpdateManyMutationInput,
        where: types.PasswordResetTokenWhereInput,
    ) -> int:
        """Update multiple PasswordResetToken records

        Parameters
        ----------
        data
            PasswordResetToken data to update the selected PasswordResetToken records to
        where
            Filter to select the PasswordResetToken records to update

        Returns
        -------
        int
            The total number of PasswordResetToken records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PasswordResetToken records
        total = await PasswordResetToken.prisma().update_many(
            data={
                'id': 'bacecgfhbe'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PasswordResetTokenWhereInput] = None,
        cursor: Optional[types.PasswordResetTokenWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PasswordResetToken records present in the database

        Parameters
        ----------
        select
            Select the PasswordResetToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PasswordResetToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PasswordResetTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PasswordResetToken.prisma().count()

        # results: prisma.types.PasswordResetTokenCountAggregateOutput
        results = await PasswordResetToken.prisma().count(
            select={
                '_all': True,
                'token': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PasswordResetTokenCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PasswordResetTokenWhereInput] = None,
        cursor: Optional[types.PasswordResetTokenWhereUniqueInput] = None,
    ) -> types.PasswordResetTokenCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PasswordResetTokenCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PasswordResetTokenWhereInput] = None,
        cursor: Optional[types.PasswordResetTokenWhereUniqueInput] = None,
    ) -> Union[int, types.PasswordResetTokenCountAggregateOutput]:
        """Count the number of PasswordResetToken records present in the database

        Parameters
        ----------
        select
            Select the PasswordResetToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PasswordResetToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PasswordResetTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PasswordResetToken.prisma().count()

        # results: prisma.types.PasswordResetTokenCountAggregateOutput
        results = await PasswordResetToken.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PasswordResetTokenCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PasswordResetTokenWhereInput] = None
    ) -> int:
        """Delete multiple PasswordResetToken records.

        Parameters
        ----------
        where
            Optional PasswordResetToken filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PasswordResetToken records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PasswordResetToken records
        total = await PasswordResetToken.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PasswordResetTokenScalarFieldKeys'],
        *,
        where: Optional['types.PasswordResetTokenWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PasswordResetTokenAvgAggregateInput'] = None,
        sum: Optional['types.PasswordResetTokenSumAggregateInput'] = None,
        min: Optional['types.PasswordResetTokenMinAggregateInput'] = None,
        max: Optional['types.PasswordResetTokenMaxAggregateInput'] = None,
        having: Optional['types.PasswordResetTokenScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PasswordResetTokenCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PasswordResetTokenScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PasswordResetTokenScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PasswordResetTokenGroupByOutput']:
        """Group PasswordResetToken records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PasswordResetToken fields to group records by
        where
            PasswordResetToken filter to select records
        take
            Limit the maximum number of PasswordResetToken records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PasswordResetTokenGroupByOutput]
            A list of dictionaries representing the PasswordResetToken record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PasswordResetToken records by expires values
        # and count how many records are in each group
        results = await PasswordResetToken.prisma().group_by(
            ['expires'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProjectActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Project]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Project.prisma().query_raw(
            'SELECT * FROM Project WHERE id = $1',
            'ihcahiead',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Project
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Project.prisma().query_first(
            'SELECT * FROM Project WHERE name = $1',
            'biheheiajg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProjectCreateInput,
        include: Optional[types.ProjectInclude] = None
    ) -> _PrismaModelT:
        """Create a new Project record.

        Parameters
        ----------
        data
            Project record data
        include
            Specifies which relations should be loaded on the returned Project model

        Returns
        -------
        prisma.models.Project
            The created Project record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Project record from just the required fields
        project = await Project.prisma().create(
            data={
                # data to create a Project record
                'name': 'jbgijghgb',
                'ownerId': 'hgjcghfbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProjectCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Project records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Project record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Project.prisma().create_many(
            data=[
                {
                    # data to create a Project record
                    'name': 'icadbcehj',
                    'ownerId': 'jchciaee',
                },
                {
                    # data to create a Project record
                    'name': 'deeificjd',
                    'ownerId': 'bbcbhebbda',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProjectWhereUniqueInput,
        include: Optional[types.ProjectInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Project record.

        Parameters
        ----------
        where
            Project filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Project model

        Returns
        -------
        prisma.models.Project
            The deleted Project record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        project = await Project.prisma().delete(
            where={
                'id': 'bejfijgcfb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProjectWhereUniqueInput,
        include: Optional[types.ProjectInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Project record.

        Parameters
        ----------
        where
            Project filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Project model

        Returns
        -------
        prisma.models.Project
            The found Project record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        project = await Project.prisma().find_unique(
            where={
                'id': 'caifcbgii',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProjectWhereUniqueInput,
        include: Optional[types.ProjectInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Project record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Project filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Project model

        Returns
        -------
        prisma.models.Project
            The found Project record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        project = await Project.prisma().find_unique_or_raise(
            where={
                'id': 'igaibbfgj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectWhereInput] = None,
        cursor: Optional[types.ProjectWhereUniqueInput] = None,
        include: Optional[types.ProjectInclude] = None,
        order: Optional[Union[types.ProjectOrderByInput, List[types.ProjectOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Project records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Project records returned
        skip
            Ignore the first N results
        where
            Project filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Project model
        order
            Order the returned Project records by any field
        distinct
            Filter Project records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Project]
            The list of all Project records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Project records
        projects = await Project.prisma().find_many(take=10)

        # find the first 5 Project records ordered by the description field
        projects = await Project.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectWhereInput] = None,
        cursor: Optional[types.ProjectWhereUniqueInput] = None,
        include: Optional[types.ProjectInclude] = None,
        order: Optional[Union[types.ProjectOrderByInput, List[types.ProjectOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Project record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Project filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Project model
        order
            Order the returned Project records by any field
        distinct
            Filter Project records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Project
            The first Project record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Project record ordered by the isFree field
        project = await Project.prisma().find_first(
            skip=1,
            order={
                'isFree': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectWhereInput] = None,
        cursor: Optional[types.ProjectWhereUniqueInput] = None,
        include: Optional[types.ProjectInclude] = None,
        order: Optional[Union[types.ProjectOrderByInput, List[types.ProjectOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Project record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Project filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Project model
        order
            Order the returned Project records by any field
        distinct
            Filter Project records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Project
            The first Project record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Project record ordered by the coinCost field
        project = await Project.prisma().find_first_or_raise(
            skip=1,
            order={
                'coinCost': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProjectUpdateInput,
        where: types.ProjectWhereUniqueInput,
        include: Optional[types.ProjectInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Project record.

        Parameters
        ----------
        data
            Project record data specifying what to update
        where
            Project filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Project model

        Returns
        -------
        prisma.models.Project
            The updated Project record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        project = await Project.prisma().update(
            where={
                'id': 'bggajdcbbi',
            },
            data={
                # data to update the Project record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProjectWhereUniqueInput,
        data: types.ProjectUpsertInput,
        include: Optional[types.ProjectInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Project filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Project model

        Returns
        -------
        prisma.models.Project
            The created or updated Project record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        project = await Project.prisma().upsert(
            where={
                'id': 'fcfhgbjed',
            },
            data={
                'create': {
                    'id': 'fcfhgbjed',
                    'name': 'deeificjd',
                    'ownerId': 'bbcbhebbda',
                },
                'update': {
                    'name': 'deeificjd',
                    'ownerId': 'bbcbhebbda',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProjectUpdateManyMutationInput,
        where: types.ProjectWhereInput,
    ) -> int:
        """Update multiple Project records

        Parameters
        ----------
        data
            Project data to update the selected Project records to
        where
            Filter to select the Project records to update

        Returns
        -------
        int
            The total number of Project records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Project records
        total = await Project.prisma().update_many(
            data={
                'ownerId': 'hdgcajhjg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectWhereInput] = None,
        cursor: Optional[types.ProjectWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Project records present in the database

        Parameters
        ----------
        select
            Select the Project fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Project filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Project.prisma().count()

        # results: prisma.types.ProjectCountAggregateOutput
        results = await Project.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProjectCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectWhereInput] = None,
        cursor: Optional[types.ProjectWhereUniqueInput] = None,
    ) -> types.ProjectCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProjectCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectWhereInput] = None,
        cursor: Optional[types.ProjectWhereUniqueInput] = None,
    ) -> Union[int, types.ProjectCountAggregateOutput]:
        """Count the number of Project records present in the database

        Parameters
        ----------
        select
            Select the Project fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Project filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Project.prisma().count()

        # results: prisma.types.ProjectCountAggregateOutput
        results = await Project.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProjectCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProjectWhereInput] = None
    ) -> int:
        """Delete multiple Project records.

        Parameters
        ----------
        where
            Optional Project filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Project records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Project records
        total = await Project.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProjectScalarFieldKeys'],
        *,
        where: Optional['types.ProjectWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProjectAvgAggregateInput'] = None,
        sum: Optional['types.ProjectSumAggregateInput'] = None,
        min: Optional['types.ProjectMinAggregateInput'] = None,
        max: Optional['types.ProjectMaxAggregateInput'] = None,
        having: Optional['types.ProjectScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProjectCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProjectScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProjectScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProjectGroupByOutput']:
        """Group Project records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Project fields to group records by
        where
            Project filter to select records
        take
            Limit the maximum number of Project records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProjectGroupByOutput]
            A list of dictionaries representing the Project record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Project records by id values
        # and count how many records are in each group
        results = await Project.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProjectFileActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ProjectFile]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ProjectFile.prisma().query_raw(
            'SELECT * FROM ProjectFile WHERE id = $1',
            'ejdjahicb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ProjectFile
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ProjectFile.prisma().query_first(
            'SELECT * FROM ProjectFile WHERE projectId = $1',
            'gdjgigfgc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProjectFileCreateInput,
        include: Optional[types.ProjectFileInclude] = None
    ) -> _PrismaModelT:
        """Create a new ProjectFile record.

        Parameters
        ----------
        data
            ProjectFile record data
        include
            Specifies which relations should be loaded on the returned ProjectFile model

        Returns
        -------
        prisma.models.ProjectFile
            The created ProjectFile record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ProjectFile record from just the required fields
        projectfile = await ProjectFile.prisma().create(
            data={
                # data to create a ProjectFile record
                'projectId': 'gfeaahdeh',
                'fileName': 'bjafcgbffc',
                'appwriteId': 'hihegjif',
                'fileSize': 1398328302,
                'mimeType': 'ifgaaagff',
                'uploadedById': 'befcddgjce',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProjectFileCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ProjectFile records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ProjectFile record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ProjectFile.prisma().create_many(
            data=[
                {
                    # data to create a ProjectFile record
                    'projectId': 'bfhdbjjgfd',
                    'fileName': 'cabdjadaji',
                    'appwriteId': 'faajgfadf',
                    'fileSize': 1800624392,
                    'mimeType': 'cahhaghecf',
                    'uploadedById': 'bghcbbcidi',
                },
                {
                    # data to create a ProjectFile record
                    'projectId': 'jcgghhgdj',
                    'fileName': 'beehgcebbg',
                    'appwriteId': 'bhdiaidiaf',
                    'fileSize': 340946258,
                    'mimeType': 'gabahhhjf',
                    'uploadedById': 'cjagadcjg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProjectFileWhereUniqueInput,
        include: Optional[types.ProjectFileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ProjectFile record.

        Parameters
        ----------
        where
            ProjectFile filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectFile model

        Returns
        -------
        prisma.models.ProjectFile
            The deleted ProjectFile record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectfile = await ProjectFile.prisma().delete(
            where={
                'id': 'bifficggej',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProjectFileWhereUniqueInput,
        include: Optional[types.ProjectFileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ProjectFile record.

        Parameters
        ----------
        where
            ProjectFile filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectFile model

        Returns
        -------
        prisma.models.ProjectFile
            The found ProjectFile record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectfile = await ProjectFile.prisma().find_unique(
            where={
                'id': 'bgbbaajbic',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProjectFileWhereUniqueInput,
        include: Optional[types.ProjectFileInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ProjectFile record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ProjectFile filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectFile model

        Returns
        -------
        prisma.models.ProjectFile
            The found ProjectFile record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectfile = await ProjectFile.prisma().find_unique_or_raise(
            where={
                'id': 'eegghdhjb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectFileWhereInput] = None,
        cursor: Optional[types.ProjectFileWhereUniqueInput] = None,
        include: Optional[types.ProjectFileInclude] = None,
        order: Optional[Union[types.ProjectFileOrderByInput, List[types.ProjectFileOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectFileScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ProjectFile records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ProjectFile records returned
        skip
            Ignore the first N results
        where
            ProjectFile filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectFile model
        order
            Order the returned ProjectFile records by any field
        distinct
            Filter ProjectFile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ProjectFile]
            The list of all ProjectFile records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ProjectFile records
        projectfiles = await ProjectFile.prisma().find_many(take=10)

        # find the first 5 ProjectFile records ordered by the fileName field
        projectfiles = await ProjectFile.prisma().find_many(
            take=5,
            order={
                'fileName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectFileWhereInput] = None,
        cursor: Optional[types.ProjectFileWhereUniqueInput] = None,
        include: Optional[types.ProjectFileInclude] = None,
        order: Optional[Union[types.ProjectFileOrderByInput, List[types.ProjectFileOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectFileScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ProjectFile record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProjectFile filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectFile model
        order
            Order the returned ProjectFile records by any field
        distinct
            Filter ProjectFile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProjectFile
            The first ProjectFile record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProjectFile record ordered by the appwriteId field
        projectfile = await ProjectFile.prisma().find_first(
            skip=1,
            order={
                'appwriteId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectFileWhereInput] = None,
        cursor: Optional[types.ProjectFileWhereUniqueInput] = None,
        include: Optional[types.ProjectFileInclude] = None,
        order: Optional[Union[types.ProjectFileOrderByInput, List[types.ProjectFileOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectFileScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ProjectFile record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProjectFile filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectFile model
        order
            Order the returned ProjectFile records by any field
        distinct
            Filter ProjectFile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProjectFile
            The first ProjectFile record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProjectFile record ordered by the fileSize field
        projectfile = await ProjectFile.prisma().find_first_or_raise(
            skip=1,
            order={
                'fileSize': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProjectFileUpdateInput,
        where: types.ProjectFileWhereUniqueInput,
        include: Optional[types.ProjectFileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ProjectFile record.

        Parameters
        ----------
        data
            ProjectFile record data specifying what to update
        where
            ProjectFile filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ProjectFile model

        Returns
        -------
        prisma.models.ProjectFile
            The updated ProjectFile record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        projectfile = await ProjectFile.prisma().update(
            where={
                'id': 'daafgidjg',
            },
            data={
                # data to update the ProjectFile record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProjectFileWhereUniqueInput,
        data: types.ProjectFileUpsertInput,
        include: Optional[types.ProjectFileInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ProjectFile filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ProjectFile model

        Returns
        -------
        prisma.models.ProjectFile
            The created or updated ProjectFile record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectfile = await ProjectFile.prisma().upsert(
            where={
                'id': 'gdcgcgagj',
            },
            data={
                'create': {
                    'id': 'gdcgcgagj',
                    'projectId': 'jcgghhgdj',
                    'fileName': 'beehgcebbg',
                    'appwriteId': 'bhdiaidiaf',
                    'fileSize': 340946258,
                    'mimeType': 'gabahhhjf',
                    'uploadedById': 'cjagadcjg',
                },
                'update': {
                    'projectId': 'jcgghhgdj',
                    'fileName': 'beehgcebbg',
                    'appwriteId': 'bhdiaidiaf',
                    'fileSize': 340946258,
                    'mimeType': 'gabahhhjf',
                    'uploadedById': 'cjagadcjg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProjectFileUpdateManyMutationInput,
        where: types.ProjectFileWhereInput,
    ) -> int:
        """Update multiple ProjectFile records

        Parameters
        ----------
        data
            ProjectFile data to update the selected ProjectFile records to
        where
            Filter to select the ProjectFile records to update

        Returns
        -------
        int
            The total number of ProjectFile records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ProjectFile records
        total = await ProjectFile.prisma().update_many(
            data={
                'mimeType': 'bhceabbgja'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectFileWhereInput] = None,
        cursor: Optional[types.ProjectFileWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ProjectFile records present in the database

        Parameters
        ----------
        select
            Select the ProjectFile fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProjectFile filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectFileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProjectFile.prisma().count()

        # results: prisma.types.ProjectFileCountAggregateOutput
        results = await ProjectFile.prisma().count(
            select={
                '_all': True,
                'fileUrl': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProjectFileCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectFileWhereInput] = None,
        cursor: Optional[types.ProjectFileWhereUniqueInput] = None,
    ) -> types.ProjectFileCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProjectFileCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectFileWhereInput] = None,
        cursor: Optional[types.ProjectFileWhereUniqueInput] = None,
    ) -> Union[int, types.ProjectFileCountAggregateOutput]:
        """Count the number of ProjectFile records present in the database

        Parameters
        ----------
        select
            Select the ProjectFile fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProjectFile filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectFileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProjectFile.prisma().count()

        # results: prisma.types.ProjectFileCountAggregateOutput
        results = await ProjectFile.prisma().count(
            select={
                '_all': True,
                'isPublic': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProjectFileCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProjectFileWhereInput] = None
    ) -> int:
        """Delete multiple ProjectFile records.

        Parameters
        ----------
        where
            Optional ProjectFile filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ProjectFile records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ProjectFile records
        total = await ProjectFile.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProjectFileScalarFieldKeys'],
        *,
        where: Optional['types.ProjectFileWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProjectFileAvgAggregateInput'] = None,
        sum: Optional['types.ProjectFileSumAggregateInput'] = None,
        min: Optional['types.ProjectFileMinAggregateInput'] = None,
        max: Optional['types.ProjectFileMaxAggregateInput'] = None,
        having: Optional['types.ProjectFileScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProjectFileCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProjectFileScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProjectFileScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProjectFileGroupByOutput']:
        """Group ProjectFile records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ProjectFile fields to group records by
        where
            ProjectFile filter to select records
        take
            Limit the maximum number of ProjectFile records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProjectFileGroupByOutput]
            A list of dictionaries representing the ProjectFile record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ProjectFile records by uploadedById values
        # and count how many records are in each group
        results = await ProjectFile.prisma().group_by(
            ['uploadedById'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PostActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Post]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Post.prisma().query_raw(
            'SELECT * FROM Post WHERE id = $1',
            'ehabfhegh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Post
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Post.prisma().query_first(
            'SELECT * FROM Post WHERE title = $1',
            'bcajcajjbc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PostCreateInput,
        include: Optional[types.PostInclude] = None
    ) -> _PrismaModelT:
        """Create a new Post record.

        Parameters
        ----------
        data
            Post record data
        include
            Specifies which relations should be loaded on the returned Post model

        Returns
        -------
        prisma.models.Post
            The created Post record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Post record from just the required fields
        post = await Post.prisma().create(
            data={
                # data to create a Post record
                'title': 'bfdgheeegf',
                'markdown': 'ececbijji',
                'authorId': 'cbcfgdcdhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PostCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Post records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Post record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Post.prisma().create_many(
            data=[
                {
                    # data to create a Post record
                    'title': 'fdgjfbhia',
                    'markdown': 'jcehcdchh',
                    'authorId': 'bgcbjdhjcc',
                },
                {
                    # data to create a Post record
                    'title': 'bieiidcabj',
                    'markdown': 'bjcbfcieaa',
                    'authorId': 'cbaaechiej',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PostWhereUniqueInput,
        include: Optional[types.PostInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Post record.

        Parameters
        ----------
        where
            Post filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Post model

        Returns
        -------
        prisma.models.Post
            The deleted Post record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        post = await Post.prisma().delete(
            where={
                'id': 'iejbeaaeg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PostWhereUniqueInput,
        include: Optional[types.PostInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Post record.

        Parameters
        ----------
        where
            Post filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Post model

        Returns
        -------
        prisma.models.Post
            The found Post record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        post = await Post.prisma().find_unique(
            where={
                'id': 'jcibfcbhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PostWhereUniqueInput,
        include: Optional[types.PostInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Post record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Post filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Post model

        Returns
        -------
        prisma.models.Post
            The found Post record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        post = await Post.prisma().find_unique_or_raise(
            where={
                'id': 'chdadcaga',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PostWhereInput] = None,
        cursor: Optional[types.PostWhereUniqueInput] = None,
        include: Optional[types.PostInclude] = None,
        order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
        distinct: Optional[List[types.PostScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Post records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Post records returned
        skip
            Ignore the first N results
        where
            Post filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Post model
        order
            Order the returned Post records by any field
        distinct
            Filter Post records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Post]
            The list of all Post records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Post records
        posts = await Post.prisma().find_many(take=10)

        # find the first 5 Post records ordered by the description field
        posts = await Post.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PostWhereInput] = None,
        cursor: Optional[types.PostWhereUniqueInput] = None,
        include: Optional[types.PostInclude] = None,
        order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
        distinct: Optional[List[types.PostScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Post record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Post filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Post model
        order
            Order the returned Post records by any field
        distinct
            Filter Post records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Post
            The first Post record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Post record ordered by the markdown field
        post = await Post.prisma().find_first(
            skip=1,
            order={
                'markdown': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PostWhereInput] = None,
        cursor: Optional[types.PostWhereUniqueInput] = None,
        include: Optional[types.PostInclude] = None,
        order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
        distinct: Optional[List[types.PostScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Post record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Post filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Post model
        order
            Order the returned Post records by any field
        distinct
            Filter Post records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Post
            The first Post record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Post record ordered by the tags field
        post = await Post.prisma().find_first_or_raise(
            skip=1,
            order={
                'tags': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PostUpdateInput,
        where: types.PostWhereUniqueInput,
        include: Optional[types.PostInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Post record.

        Parameters
        ----------
        data
            Post record data specifying what to update
        where
            Post filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Post model

        Returns
        -------
        prisma.models.Post
            The updated Post record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        post = await Post.prisma().update(
            where={
                'id': 'jicieifbh',
            },
            data={
                # data to update the Post record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PostWhereUniqueInput,
        data: types.PostUpsertInput,
        include: Optional[types.PostInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Post filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Post model

        Returns
        -------
        prisma.models.Post
            The created or updated Post record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        post = await Post.prisma().upsert(
            where={
                'id': 'fbahdheji',
            },
            data={
                'create': {
                    'id': 'fbahdheji',
                    'title': 'bieiidcabj',
                    'markdown': 'bjcbfcieaa',
                    'authorId': 'cbaaechiej',
                },
                'update': {
                    'title': 'bieiidcabj',
                    'markdown': 'bjcbfcieaa',
                    'authorId': 'cbaaechiej',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PostUpdateManyMutationInput,
        where: types.PostWhereInput,
    ) -> int:
        """Update multiple Post records

        Parameters
        ----------
        data
            Post data to update the selected Post records to
        where
            Filter to select the Post records to update

        Returns
        -------
        int
            The total number of Post records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Post records
        total = await Post.prisma().update_many(
            data={
                'feature': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PostWhereInput] = None,
        cursor: Optional[types.PostWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Post records present in the database

        Parameters
        ----------
        select
            Select the Post fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Post filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PostCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Post.prisma().count()

        # results: prisma.types.PostCountAggregateOutput
        results = await Post.prisma().count(
            select={
                '_all': True,
                'authorId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PostCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PostWhereInput] = None,
        cursor: Optional[types.PostWhereUniqueInput] = None,
    ) -> types.PostCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PostCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PostWhereInput] = None,
        cursor: Optional[types.PostWhereUniqueInput] = None,
    ) -> Union[int, types.PostCountAggregateOutput]:
        """Count the number of Post records present in the database

        Parameters
        ----------
        select
            Select the Post fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Post filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PostCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Post.prisma().count()

        # results: prisma.types.PostCountAggregateOutput
        results = await Post.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PostCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PostWhereInput] = None
    ) -> int:
        """Delete multiple Post records.

        Parameters
        ----------
        where
            Optional Post filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Post records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Post records
        total = await Post.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PostScalarFieldKeys'],
        *,
        where: Optional['types.PostWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PostAvgAggregateInput'] = None,
        sum: Optional['types.PostSumAggregateInput'] = None,
        min: Optional['types.PostMinAggregateInput'] = None,
        max: Optional['types.PostMaxAggregateInput'] = None,
        having: Optional['types.PostScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PostCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PostScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PostScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PostGroupByOutput']:
        """Group Post records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Post fields to group records by
        where
            Post filter to select records
        take
            Limit the maximum number of Post records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PostGroupByOutput]
            A list of dictionaries representing the Post record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Post records by updatedAt values
        # and count how many records are in each group
        results = await Post.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LikeActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Like]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Like.prisma().query_raw(
            'SELECT * FROM Like WHERE id = $1',
            'beabjeejdg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Like
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Like.prisma().query_first(
            'SELECT * FROM Like WHERE userId = $1',
            'bcjhgahffd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LikeCreateInput,
        include: Optional[types.LikeInclude] = None
    ) -> _PrismaModelT:
        """Create a new Like record.

        Parameters
        ----------
        data
            Like record data
        include
            Specifies which relations should be loaded on the returned Like model

        Returns
        -------
        prisma.models.Like
            The created Like record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Like record from just the required fields
        like = await Like.prisma().create(
            data={
                # data to create a Like record
                'userId': 'fbjeiiffa',
                'postId': 'jhgidcgbf',
                'value': 1696425492,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LikeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Like records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Like record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Like.prisma().create_many(
            data=[
                {
                    # data to create a Like record
                    'userId': 'bgjcgchib',
                    'postId': 'bacdaibgfa',
                    'value': 327681027,
                },
                {
                    # data to create a Like record
                    'userId': 'fchheijjc',
                    'postId': 'cacjdfhejh',
                    'value': 1318597118,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LikeWhereUniqueInput,
        include: Optional[types.LikeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Like record.

        Parameters
        ----------
        where
            Like filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Like model

        Returns
        -------
        prisma.models.Like
            The deleted Like record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        like = await Like.prisma().delete(
            where={
                'id': 'cbccbbcdfb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LikeWhereUniqueInput,
        include: Optional[types.LikeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Like record.

        Parameters
        ----------
        where
            Like filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Like model

        Returns
        -------
        prisma.models.Like
            The found Like record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        like = await Like.prisma().find_unique(
            where={
                'id': 'bacejedaca',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LikeWhereUniqueInput,
        include: Optional[types.LikeInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Like record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Like filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Like model

        Returns
        -------
        prisma.models.Like
            The found Like record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        like = await Like.prisma().find_unique_or_raise(
            where={
                'id': 'bhbhdahfaj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LikeWhereInput] = None,
        cursor: Optional[types.LikeWhereUniqueInput] = None,
        include: Optional[types.LikeInclude] = None,
        order: Optional[Union[types.LikeOrderByInput, List[types.LikeOrderByInput]]] = None,
        distinct: Optional[List[types.LikeScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Like records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Like records returned
        skip
            Ignore the first N results
        where
            Like filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Like model
        order
            Order the returned Like records by any field
        distinct
            Filter Like records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Like]
            The list of all Like records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Like records
        likes = await Like.prisma().find_many(take=10)

        # find the first 5 Like records ordered by the postId field
        likes = await Like.prisma().find_many(
            take=5,
            order={
                'postId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LikeWhereInput] = None,
        cursor: Optional[types.LikeWhereUniqueInput] = None,
        include: Optional[types.LikeInclude] = None,
        order: Optional[Union[types.LikeOrderByInput, List[types.LikeOrderByInput]]] = None,
        distinct: Optional[List[types.LikeScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Like record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Like filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Like model
        order
            Order the returned Like records by any field
        distinct
            Filter Like records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Like
            The first Like record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Like record ordered by the value field
        like = await Like.prisma().find_first(
            skip=1,
            order={
                'value': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LikeWhereInput] = None,
        cursor: Optional[types.LikeWhereUniqueInput] = None,
        include: Optional[types.LikeInclude] = None,
        order: Optional[Union[types.LikeOrderByInput, List[types.LikeOrderByInput]]] = None,
        distinct: Optional[List[types.LikeScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Like record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Like filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Like model
        order
            Order the returned Like records by any field
        distinct
            Filter Like records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Like
            The first Like record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Like record ordered by the createdAt field
        like = await Like.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LikeUpdateInput,
        where: types.LikeWhereUniqueInput,
        include: Optional[types.LikeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Like record.

        Parameters
        ----------
        data
            Like record data specifying what to update
        where
            Like filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Like model

        Returns
        -------
        prisma.models.Like
            The updated Like record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        like = await Like.prisma().update(
            where={
                'id': 'bfjibceaec',
            },
            data={
                # data to update the Like record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LikeWhereUniqueInput,
        data: types.LikeUpsertInput,
        include: Optional[types.LikeInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Like filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Like model

        Returns
        -------
        prisma.models.Like
            The created or updated Like record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        like = await Like.prisma().upsert(
            where={
                'id': 'ibhgcdbgd',
            },
            data={
                'create': {
                    'id': 'ibhgcdbgd',
                    'userId': 'fchheijjc',
                    'postId': 'cacjdfhejh',
                    'value': 1318597118,
                },
                'update': {
                    'userId': 'fchheijjc',
                    'postId': 'cacjdfhejh',
                    'value': 1318597118,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LikeUpdateManyMutationInput,
        where: types.LikeWhereInput,
    ) -> int:
        """Update multiple Like records

        Parameters
        ----------
        data
            Like data to update the selected Like records to
        where
            Filter to select the Like records to update

        Returns
        -------
        int
            The total number of Like records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Like records
        total = await Like.prisma().update_many(
            data={
                'id': 'badaffhddg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LikeWhereInput] = None,
        cursor: Optional[types.LikeWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Like records present in the database

        Parameters
        ----------
        select
            Select the Like fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Like filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LikeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Like.prisma().count()

        # results: prisma.types.LikeCountAggregateOutput
        results = await Like.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LikeCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LikeWhereInput] = None,
        cursor: Optional[types.LikeWhereUniqueInput] = None,
    ) -> types.LikeCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LikeCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LikeWhereInput] = None,
        cursor: Optional[types.LikeWhereUniqueInput] = None,
    ) -> Union[int, types.LikeCountAggregateOutput]:
        """Count the number of Like records present in the database

        Parameters
        ----------
        select
            Select the Like fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Like filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LikeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Like.prisma().count()

        # results: prisma.types.LikeCountAggregateOutput
        results = await Like.prisma().count(
            select={
                '_all': True,
                'postId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LikeCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LikeWhereInput] = None
    ) -> int:
        """Delete multiple Like records.

        Parameters
        ----------
        where
            Optional Like filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Like records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Like records
        total = await Like.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LikeScalarFieldKeys'],
        *,
        where: Optional['types.LikeWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LikeAvgAggregateInput'] = None,
        sum: Optional['types.LikeSumAggregateInput'] = None,
        min: Optional['types.LikeMinAggregateInput'] = None,
        max: Optional['types.LikeMaxAggregateInput'] = None,
        having: Optional['types.LikeScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LikeCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LikeScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LikeScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LikeGroupByOutput']:
        """Group Like records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Like fields to group records by
        where
            Like filter to select records
        take
            Limit the maximum number of Like records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LikeGroupByOutput]
            A list of dictionaries representing the Like record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Like records by value values
        # and count how many records are in each group
        results = await Like.prisma().group_by(
            ['value'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class FollowActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Follow]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Follow.prisma().query_raw(
            'SELECT * FROM Follow WHERE id = $1',
            'bbdbfcfihd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Follow
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Follow.prisma().query_first(
            'SELECT * FROM Follow WHERE followerId = $1',
            'cbagggbji',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.FollowCreateInput,
        include: Optional[types.FollowInclude] = None
    ) -> _PrismaModelT:
        """Create a new Follow record.

        Parameters
        ----------
        data
            Follow record data
        include
            Specifies which relations should be loaded on the returned Follow model

        Returns
        -------
        prisma.models.Follow
            The created Follow record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Follow record from just the required fields
        follow = await Follow.prisma().create(
            data={
                # data to create a Follow record
                'followerId': 'bchgafhjed',
                'followingId': 'heffgjdei',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.FollowCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Follow records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Follow record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Follow.prisma().create_many(
            data=[
                {
                    # data to create a Follow record
                    'followerId': 'dahihgbeb',
                    'followingId': 'bgheaejbcc',
                },
                {
                    # data to create a Follow record
                    'followerId': 'bfcgifeged',
                    'followingId': 'jfiahhbae',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.FollowWhereUniqueInput,
        include: Optional[types.FollowInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Follow record.

        Parameters
        ----------
        where
            Follow filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Follow model

        Returns
        -------
        prisma.models.Follow
            The deleted Follow record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        follow = await Follow.prisma().delete(
            where={
                'id': 'bfbdafajcb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.FollowWhereUniqueInput,
        include: Optional[types.FollowInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Follow record.

        Parameters
        ----------
        where
            Follow filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Follow model

        Returns
        -------
        prisma.models.Follow
            The found Follow record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        follow = await Follow.prisma().find_unique(
            where={
                'id': 'caeghehde',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.FollowWhereUniqueInput,
        include: Optional[types.FollowInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Follow record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Follow filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Follow model

        Returns
        -------
        prisma.models.Follow
            The found Follow record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        follow = await Follow.prisma().find_unique_or_raise(
            where={
                'id': 'caghgfbggd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FollowWhereInput] = None,
        cursor: Optional[types.FollowWhereUniqueInput] = None,
        include: Optional[types.FollowInclude] = None,
        order: Optional[Union[types.FollowOrderByInput, List[types.FollowOrderByInput]]] = None,
        distinct: Optional[List[types.FollowScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Follow records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Follow records returned
        skip
            Ignore the first N results
        where
            Follow filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Follow model
        order
            Order the returned Follow records by any field
        distinct
            Filter Follow records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Follow]
            The list of all Follow records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Follow records
        follows = await Follow.prisma().find_many(take=10)

        # find the first 5 Follow records ordered by the followingId field
        follows = await Follow.prisma().find_many(
            take=5,
            order={
                'followingId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FollowWhereInput] = None,
        cursor: Optional[types.FollowWhereUniqueInput] = None,
        include: Optional[types.FollowInclude] = None,
        order: Optional[Union[types.FollowOrderByInput, List[types.FollowOrderByInput]]] = None,
        distinct: Optional[List[types.FollowScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Follow record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Follow filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Follow model
        order
            Order the returned Follow records by any field
        distinct
            Filter Follow records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Follow
            The first Follow record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Follow record ordered by the createdAt field
        follow = await Follow.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FollowWhereInput] = None,
        cursor: Optional[types.FollowWhereUniqueInput] = None,
        include: Optional[types.FollowInclude] = None,
        order: Optional[Union[types.FollowOrderByInput, List[types.FollowOrderByInput]]] = None,
        distinct: Optional[List[types.FollowScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Follow record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Follow filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Follow model
        order
            Order the returned Follow records by any field
        distinct
            Filter Follow records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Follow
            The first Follow record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Follow record ordered by the id field
        follow = await Follow.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.FollowUpdateInput,
        where: types.FollowWhereUniqueInput,
        include: Optional[types.FollowInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Follow record.

        Parameters
        ----------
        data
            Follow record data specifying what to update
        where
            Follow filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Follow model

        Returns
        -------
        prisma.models.Follow
            The updated Follow record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        follow = await Follow.prisma().update(
            where={
                'id': 'bbidjbbjaa',
            },
            data={
                # data to update the Follow record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.FollowWhereUniqueInput,
        data: types.FollowUpsertInput,
        include: Optional[types.FollowInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Follow filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Follow model

        Returns
        -------
        prisma.models.Follow
            The created or updated Follow record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        follow = await Follow.prisma().upsert(
            where={
                'id': 'bfijhaejdd',
            },
            data={
                'create': {
                    'id': 'bfijhaejdd',
                    'followerId': 'bfcgifeged',
                    'followingId': 'jfiahhbae',
                },
                'update': {
                    'followerId': 'bfcgifeged',
                    'followingId': 'jfiahhbae',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.FollowUpdateManyMutationInput,
        where: types.FollowWhereInput,
    ) -> int:
        """Update multiple Follow records

        Parameters
        ----------
        data
            Follow data to update the selected Follow records to
        where
            Filter to select the Follow records to update

        Returns
        -------
        int
            The total number of Follow records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Follow records
        total = await Follow.prisma().update_many(
            data={
                'followerId': 'bcedehfiji'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FollowWhereInput] = None,
        cursor: Optional[types.FollowWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Follow records present in the database

        Parameters
        ----------
        select
            Select the Follow fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Follow filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FollowCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Follow.prisma().count()

        # results: prisma.types.FollowCountAggregateOutput
        results = await Follow.prisma().count(
            select={
                '_all': True,
                'followingId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.FollowCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FollowWhereInput] = None,
        cursor: Optional[types.FollowWhereUniqueInput] = None,
    ) -> types.FollowCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.FollowCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FollowWhereInput] = None,
        cursor: Optional[types.FollowWhereUniqueInput] = None,
    ) -> Union[int, types.FollowCountAggregateOutput]:
        """Count the number of Follow records present in the database

        Parameters
        ----------
        select
            Select the Follow fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Follow filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FollowCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Follow.prisma().count()

        # results: prisma.types.FollowCountAggregateOutput
        results = await Follow.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.FollowCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.FollowWhereInput] = None
    ) -> int:
        """Delete multiple Follow records.

        Parameters
        ----------
        where
            Optional Follow filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Follow records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Follow records
        total = await Follow.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.FollowScalarFieldKeys'],
        *,
        where: Optional['types.FollowWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.FollowAvgAggregateInput'] = None,
        sum: Optional['types.FollowSumAggregateInput'] = None,
        min: Optional['types.FollowMinAggregateInput'] = None,
        max: Optional['types.FollowMaxAggregateInput'] = None,
        having: Optional['types.FollowScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.FollowCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.FollowScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.FollowScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.FollowGroupByOutput']:
        """Group Follow records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Follow fields to group records by
        where
            Follow filter to select records
        take
            Limit the maximum number of Follow records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.FollowGroupByOutput]
            A list of dictionaries representing the Follow record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Follow records by id values
        # and count how many records are in each group
        results = await Follow.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SecurityAuditLogActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.SecurityAuditLog]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await SecurityAuditLog.prisma().query_raw(
            'SELECT * FROM SecurityAuditLog WHERE id = $1',
            'bdgjicijhb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.SecurityAuditLog
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await SecurityAuditLog.prisma().query_first(
            'SELECT * FROM SecurityAuditLog WHERE event = $1',
            'bghifjdeia',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SecurityAuditLogCreateInput,
        include: Optional[types.SecurityAuditLogInclude] = None
    ) -> _PrismaModelT:
        """Create a new SecurityAuditLog record.

        Parameters
        ----------
        data
            SecurityAuditLog record data
        include
            Specifies which relations should be loaded on the returned SecurityAuditLog model

        Returns
        -------
        prisma.models.SecurityAuditLog
            The created SecurityAuditLog record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a SecurityAuditLog record from just the required fields
        securityauditlog = await SecurityAuditLog.prisma().create(
            data={
                # data to create a SecurityAuditLog record
                'event': 'eadfcbbcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SecurityAuditLogCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple SecurityAuditLog records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of SecurityAuditLog record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await SecurityAuditLog.prisma().create_many(
            data=[
                {
                    # data to create a SecurityAuditLog record
                    'event': 'geihgahba',
                },
                {
                    # data to create a SecurityAuditLog record
                    'event': 'gahdcdhbj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SecurityAuditLogWhereUniqueInput,
        include: Optional[types.SecurityAuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single SecurityAuditLog record.

        Parameters
        ----------
        where
            SecurityAuditLog filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned SecurityAuditLog model

        Returns
        -------
        prisma.models.SecurityAuditLog
            The deleted SecurityAuditLog record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        securityauditlog = await SecurityAuditLog.prisma().delete(
            where={
                'id': 'begiijahea',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SecurityAuditLogWhereUniqueInput,
        include: Optional[types.SecurityAuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique SecurityAuditLog record.

        Parameters
        ----------
        where
            SecurityAuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SecurityAuditLog model

        Returns
        -------
        prisma.models.SecurityAuditLog
            The found SecurityAuditLog record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        securityauditlog = await SecurityAuditLog.prisma().find_unique(
            where={
                'id': 'gcjadjaaf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SecurityAuditLogWhereUniqueInput,
        include: Optional[types.SecurityAuditLogInclude] = None
    ) -> _PrismaModelT:
        """Find a unique SecurityAuditLog record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            SecurityAuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SecurityAuditLog model

        Returns
        -------
        prisma.models.SecurityAuditLog
            The found SecurityAuditLog record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        securityauditlog = await SecurityAuditLog.prisma().find_unique_or_raise(
            where={
                'id': 'bcbebgiaic',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SecurityAuditLogWhereInput] = None,
        cursor: Optional[types.SecurityAuditLogWhereUniqueInput] = None,
        include: Optional[types.SecurityAuditLogInclude] = None,
        order: Optional[Union[types.SecurityAuditLogOrderByInput, List[types.SecurityAuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.SecurityAuditLogScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple SecurityAuditLog records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of SecurityAuditLog records returned
        skip
            Ignore the first N results
        where
            SecurityAuditLog filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SecurityAuditLog model
        order
            Order the returned SecurityAuditLog records by any field
        distinct
            Filter SecurityAuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.SecurityAuditLog]
            The list of all SecurityAuditLog records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 SecurityAuditLog records
        securityauditlogs = await SecurityAuditLog.prisma().find_many(take=10)

        # find the first 5 SecurityAuditLog records ordered by the userId field
        securityauditlogs = await SecurityAuditLog.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SecurityAuditLogWhereInput] = None,
        cursor: Optional[types.SecurityAuditLogWhereUniqueInput] = None,
        include: Optional[types.SecurityAuditLogInclude] = None,
        order: Optional[Union[types.SecurityAuditLogOrderByInput, List[types.SecurityAuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.SecurityAuditLogScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single SecurityAuditLog record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SecurityAuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SecurityAuditLog model
        order
            Order the returned SecurityAuditLog records by any field
        distinct
            Filter SecurityAuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SecurityAuditLog
            The first SecurityAuditLog record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SecurityAuditLog record ordered by the details field
        securityauditlog = await SecurityAuditLog.prisma().find_first(
            skip=1,
            order={
                'details': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SecurityAuditLogWhereInput] = None,
        cursor: Optional[types.SecurityAuditLogWhereUniqueInput] = None,
        include: Optional[types.SecurityAuditLogInclude] = None,
        order: Optional[Union[types.SecurityAuditLogOrderByInput, List[types.SecurityAuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.SecurityAuditLogScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single SecurityAuditLog record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SecurityAuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SecurityAuditLog model
        order
            Order the returned SecurityAuditLog records by any field
        distinct
            Filter SecurityAuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SecurityAuditLog
            The first SecurityAuditLog record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SecurityAuditLog record ordered by the ipAddress field
        securityauditlog = await SecurityAuditLog.prisma().find_first_or_raise(
            skip=1,
            order={
                'ipAddress': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SecurityAuditLogUpdateInput,
        where: types.SecurityAuditLogWhereUniqueInput,
        include: Optional[types.SecurityAuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single SecurityAuditLog record.

        Parameters
        ----------
        data
            SecurityAuditLog record data specifying what to update
        where
            SecurityAuditLog filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned SecurityAuditLog model

        Returns
        -------
        prisma.models.SecurityAuditLog
            The updated SecurityAuditLog record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        securityauditlog = await SecurityAuditLog.prisma().update(
            where={
                'id': 'ijigbdcbj',
            },
            data={
                # data to update the SecurityAuditLog record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SecurityAuditLogWhereUniqueInput,
        data: types.SecurityAuditLogUpsertInput,
        include: Optional[types.SecurityAuditLogInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            SecurityAuditLog filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned SecurityAuditLog model

        Returns
        -------
        prisma.models.SecurityAuditLog
            The created or updated SecurityAuditLog record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        securityauditlog = await SecurityAuditLog.prisma().upsert(
            where={
                'id': 'gfidhicai',
            },
            data={
                'create': {
                    'id': 'gfidhicai',
                    'event': 'gahdcdhbj',
                },
                'update': {
                    'event': 'gahdcdhbj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SecurityAuditLogUpdateManyMutationInput,
        where: types.SecurityAuditLogWhereInput,
    ) -> int:
        """Update multiple SecurityAuditLog records

        Parameters
        ----------
        data
            SecurityAuditLog data to update the selected SecurityAuditLog records to
        where
            Filter to select the SecurityAuditLog records to update

        Returns
        -------
        int
            The total number of SecurityAuditLog records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all SecurityAuditLog records
        total = await SecurityAuditLog.prisma().update_many(
            data={
                'userAgent': 'jfegcaafh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SecurityAuditLogWhereInput] = None,
        cursor: Optional[types.SecurityAuditLogWhereUniqueInput] = None,
    ) -> int:
        """Count the number of SecurityAuditLog records present in the database

        Parameters
        ----------
        select
            Select the SecurityAuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SecurityAuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SecurityAuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SecurityAuditLog.prisma().count()

        # results: prisma.types.SecurityAuditLogCountAggregateOutput
        results = await SecurityAuditLog.prisma().count(
            select={
                '_all': True,
                'timestamp': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SecurityAuditLogCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SecurityAuditLogWhereInput] = None,
        cursor: Optional[types.SecurityAuditLogWhereUniqueInput] = None,
    ) -> types.SecurityAuditLogCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SecurityAuditLogCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SecurityAuditLogWhereInput] = None,
        cursor: Optional[types.SecurityAuditLogWhereUniqueInput] = None,
    ) -> Union[int, types.SecurityAuditLogCountAggregateOutput]:
        """Count the number of SecurityAuditLog records present in the database

        Parameters
        ----------
        select
            Select the SecurityAuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SecurityAuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SecurityAuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SecurityAuditLog.prisma().count()

        # results: prisma.types.SecurityAuditLogCountAggregateOutput
        results = await SecurityAuditLog.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SecurityAuditLogCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SecurityAuditLogWhereInput] = None
    ) -> int:
        """Delete multiple SecurityAuditLog records.

        Parameters
        ----------
        where
            Optional SecurityAuditLog filter to find the records to be deleted

        Returns
        -------
        int
            The total number of SecurityAuditLog records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all SecurityAuditLog records
        total = await SecurityAuditLog.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SecurityAuditLogScalarFieldKeys'],
        *,
        where: Optional['types.SecurityAuditLogWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SecurityAuditLogAvgAggregateInput'] = None,
        sum: Optional['types.SecurityAuditLogSumAggregateInput'] = None,
        min: Optional['types.SecurityAuditLogMinAggregateInput'] = None,
        max: Optional['types.SecurityAuditLogMaxAggregateInput'] = None,
        having: Optional['types.SecurityAuditLogScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SecurityAuditLogCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SecurityAuditLogScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SecurityAuditLogScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SecurityAuditLogGroupByOutput']:
        """Group SecurityAuditLog records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar SecurityAuditLog fields to group records by
        where
            SecurityAuditLog filter to select records
        take
            Limit the maximum number of SecurityAuditLog records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SecurityAuditLogGroupByOutput]
            A list of dictionaries representing the SecurityAuditLog record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group SecurityAuditLog records by event values
        # and count how many records are in each group
        results = await SecurityAuditLog.prisma().group_by(
            ['event'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models